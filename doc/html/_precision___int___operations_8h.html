<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Precision: Precision/General_Base/Impl/Precision_Int_Operations.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Precision
   &#160;<span id="projectnumber">6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cda8f6e95b399098ad72a7ded9dd64b1.html">Precision</a></li><li class="navelem"><a class="el" href="dir_11d2f114510e12b732e8cd61583b4fd7.html">General_Base</a></li><li class="navelem"><a class="el" href="dir_956aa70110c06265813f068c073f195e.html">Impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Precision_Int_Operations.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &quot;Precision_Int_Operations_Arithmetic.inl&quot;</code><br />
<code>#include &quot;Precision_Int_Operations_Bitwise.inl&quot;</code><br />
<code>#include &quot;Precision_Int_Operations_Logical.inl&quot;</code><br />
<code>#include &quot;Precision_Int_Operations_Exponential.inl&quot;</code><br />
<code>#include &quot;Precision_Int_Operations_Comparisons.inl&quot;</code><br />
</div>
<p><a href="_precision___int___operations_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9058717d59ad3d921fb4f357f637f84a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a9058717d59ad3d921fb4f357f637f84a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a9058717d59ad3d921fb4f357f637f84a">Precision::Volatile::Int_Operations::add_diglist</a> (typename IntType::diglist_type &amp;diglist1, const typename IntType::diglist_type &amp;diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, typename IntType::digit_type base)</td></tr>
<tr class="separator:a9058717d59ad3d921fb4f357f637f84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96134d0ff039e6a1cf7d596db9bc17a2"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a96134d0ff039e6a1cf7d596db9bc17a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a96134d0ff039e6a1cf7d596db9bc17a2">Precision::Volatile::Int_Operations::add</a> (IntType &amp;lhs, const IntType &amp;rhs, short add_sign=1)</td></tr>
<tr class="separator:a96134d0ff039e6a1cf7d596db9bc17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c0804a153fd09bede916d85dde6236"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ac6c0804a153fd09bede916d85dde6236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ac6c0804a153fd09bede916d85dde6236">Precision::Volatile::Int_Operations::multiply_diglist</a> (IntType &amp;num, typename IntType::digit_type fac)</td></tr>
<tr class="separator:ac6c0804a153fd09bede916d85dde6236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ad4b05f9d2e26bcd2a8d23991e998444e">Precision::Volatile::Int_Operations::multiply</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee569062ed607d4451f0761ca30396d"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a1ee569062ed607d4451f0761ca30396d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a1ee569062ed607d4451f0761ca30396d">Precision::Volatile::Int_Operations::divide_mod</a> (const IntType &amp;lhs, const IntType &amp;rhs, IntType &amp;quotient, IntType &amp;modulus)</td></tr>
<tr class="separator:a1ee569062ed607d4451f0761ca30396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb9d54665f8effdee8f6558c8b9418e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a3fb9d54665f8effdee8f6558c8b9418e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a3fb9d54665f8effdee8f6558c8b9418e">Precision::Volatile::Int_Operations::bitwise_complement</a> (IntType &amp;bitstring)</td></tr>
<tr class="separator:a3fb9d54665f8effdee8f6558c8b9418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b1c74202f63d6154a720ef55ddf87"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:afa2b1c74202f63d6154a720ef55ddf87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#afa2b1c74202f63d6154a720ef55ddf87">Precision::Volatile::Int_Operations::bitwise_operation</a> (IntType &amp;lhs, const IntType &amp;rhs, unsigned short op)</td></tr>
<tr class="separator:afa2b1c74202f63d6154a720ef55ddf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a37c712840c2d1ab04a8eaddcaca8d487">Precision::Volatile::Int_Operations::bitwise_and_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09cf6405fe577b9fbe5216b9402acfd"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:af09cf6405fe577b9fbe5216b9402acfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#af09cf6405fe577b9fbe5216b9402acfd">Precision::Volatile::Int_Operations::bitwise_or_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:af09cf6405fe577b9fbe5216b9402acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a47c73aad4c2c9c6af253aa9e6561e2c8">Precision::Volatile::Int_Operations::bitwise_xor_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c42bf237e13b783eb25964ab8864753"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a3c42bf237e13b783eb25964ab8864753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a3c42bf237e13b783eb25964ab8864753">Precision::Volatile::Int_Operations::bitwise_lshift_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a3c42bf237e13b783eb25964ab8864753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae1f908334d24c17d35ccdcdf85004e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aeae1f908334d24c17d35ccdcdf85004e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#aeae1f908334d24c17d35ccdcdf85004e">Precision::Volatile::Int_Operations::bitwise_rshift_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:aeae1f908334d24c17d35ccdcdf85004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1962d20a311be325ea55f0c3342d412a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a1962d20a311be325ea55f0c3342d412a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a1962d20a311be325ea55f0c3342d412a">Precision::Volatile::Int_Operations::logical_operation</a> (IntType &amp;lhs, const IntType &amp;rhs, unsigned short oper)</td></tr>
<tr class="separator:a1962d20a311be325ea55f0c3342d412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042bf17ea1c0cb1faf74a4d02ad057e0"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a042bf17ea1c0cb1faf74a4d02ad057e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a042bf17ea1c0cb1faf74a4d02ad057e0">Precision::Volatile::Int_Operations::logical_and_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a042bf17ea1c0cb1faf74a4d02ad057e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eda4976a85957d0541a211625929ce"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a06eda4976a85957d0541a211625929ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a06eda4976a85957d0541a211625929ce">Precision::Volatile::Int_Operations::logical_or_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a06eda4976a85957d0541a211625929ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1686820233a58146b60d3394782353"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a8c1686820233a58146b60d3394782353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a8c1686820233a58146b60d3394782353">Precision::Volatile::Int_Operations::logical_xor_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a8c1686820233a58146b60d3394782353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c37ed972b2c8f5a7b835aa369bc767"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a75c37ed972b2c8f5a7b835aa369bc767"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a75c37ed972b2c8f5a7b835aa369bc767">Precision::Volatile::Int_Operations::logical_complement_eq</a> (IntType &amp;orig)</td></tr>
<tr class="separator:a75c37ed972b2c8f5a7b835aa369bc767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07007c8ef804c0ceb152357bdc24c0c"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ac07007c8ef804c0ceb152357bdc24c0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ac07007c8ef804c0ceb152357bdc24c0c">Precision::Volatile::Int_Operations::logical_xor_rev_eq</a> (IntType &amp;xor_res, const IntType &amp;rhs)</td></tr>
<tr class="separator:ac07007c8ef804c0ceb152357bdc24c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c5754c2c67603014af6e7b2861bce1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a68c5754c2c67603014af6e7b2861bce1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a68c5754c2c67603014af6e7b2861bce1">Precision::Volatile::Int_Operations::exponentiate</a> (IntType &amp;base, const IntType &amp;exp)</td></tr>
<tr class="separator:a68c5754c2c67603014af6e7b2861bce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556733618d611fdbeb19b1d9d05f72fe"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a556733618d611fdbeb19b1d9d05f72fe"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a556733618d611fdbeb19b1d9d05f72fe">Precision::Volatile::Int_Operations::compare</a> (const IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a556733618d611fdbeb19b1d9d05f72fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memTemplParams" colspan="2">template&lt;typename DigListType &gt; </td></tr>
<tr class="memitem:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a31307128a4a0ef31fd93a303dd8c27ca">Precision::Volatile::Int_Operations::compare_lists</a> (const DigListType &amp;diglist1, const DigListType &amp;diglist2)</td></tr>
<tr class="separator:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b1e5560a052947e97648214ec6b99a"><td class="memTemplParams" colspan="2">template&lt;typename DigListType &gt; </td></tr>
<tr class="memitem:ac0b1e5560a052947e97648214ec6b99a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ac0b1e5560a052947e97648214ec6b99a">Precision::Volatile::Int_Operations::is_zero_list</a> (const DigListType &amp;diglist)</td></tr>
<tr class="separator:ac0b1e5560a052947e97648214ec6b99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833bf7f2e703c3613c56ba0fb3e55a48"><td class="memTemplParams" colspan="2">template&lt;typename DigListType , typename SignType &gt; </td></tr>
<tr class="memitem:a833bf7f2e703c3613c56ba0fb3e55a48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a833bf7f2e703c3613c56ba0fb3e55a48">Precision::Volatile::Int_Operations::is_one_list</a> (const DigListType &amp;diglist, const SignType &amp;sign)</td></tr>
<tr class="separator:a833bf7f2e703c3613c56ba0fb3e55a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198a3d535c575aa4946f460b87ad545c"><td class="memTemplParams" colspan="2">template&lt;typename DigListType , typename SignType &gt; </td></tr>
<tr class="memitem:a198a3d535c575aa4946f460b87ad545c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a198a3d535c575aa4946f460b87ad545c">Precision::Volatile::Int_Operations::is_neg_one_list</a> (const DigListType &amp;diglist, const SignType &amp;sign)</td></tr>
<tr class="separator:a198a3d535c575aa4946f460b87ad545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file centralizes the base algorithms all the number types use. By doing this, the library can be extended more easily. An example of this is the difference between Dynamic and Static number types. Despite sharing the same algorithms, their behaviour for compile-time and run-time is different enough that they cannot share the same inheritance tree or utilize composition. The algorithms are placed under the Volatile namespace since they require the number base to be passed as a parameter to correctly run the algorithm. Most of the algorithms in here will, instead of returning a copy of the result, will store the result in the first parameter. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="file_a96134d0ff039e6a1cf7d596db9bc17a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a96134d0ff039e6a1cf7d596db9bc17a2">&sect;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::add </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>add_sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple add function taking two integers and calculating the sum.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. This function assumes IntType has the public members:<ul>
<li>Type IntType::diglist_type</li>
<li>Type IntType::sign_type</li>
<li>Type IntType::size_type</li>
<li>Type IntType::digit_type</li>
<li>Type IntType::catalyst_type</li>
<li>Method bool <a class="el" href="_precision___shared___helpers_8h.html#ade132cdfd51bb038d8b3f885b7482476">IntType::is_zero()</a></li>
<li>Method digit_type IntType::digit(size_type)</li>
<li>Method diglist_type IntType::digit_list()</li>
<li>Method size_type IntType::count_digits()</li>
<li>Method sign_type IntType::sign()</li>
<li>Method digit_type IntType::base()</li>
<li>Method void IntType::append()</li>
<li>Method void IntType::detach(digit_type)</li>
<li>Method void IntType::digit(size_type, digit_type)</li>
<li>Method sign_type IntType::sign(sign_type)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first number to add and in which to store the sum </td></tr>
    <tr><td class="paramname">rhs</td><td>The second number to add </td></tr>
    <tr><td class="paramname">add_sign</td><td>An optional specification of whether to perform a subtraction (-1) or addition (1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a9058717d59ad3d921fb4f357f637f84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a9058717d59ad3d921fb4f357f637f84a">&sect;&nbsp;</a></span>add_diglist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::add_diglist </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple add function taking two digit strings and calculating the sum. This function is kept here if another function needs to pass the digit lists and signs directly. Otherwise, <a class="el" href="_precision___int___operations_8h.html#a96134d0ff039e6a1cf7d596db9bc17a2">add()</a> is preferred.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. This function assumes IntType has the public members:<ul>
<li>Type IntType::diglist_type</li>
<li>Type IntType::sign_type</li>
<li>Type IntType::digit_type</li>
<li>Type IntType::catalyst_type</li>
<li>Method iterator diglist_type::begin()</li>
<li>Method iterator diglist_type::end()</li>
<li>Method size_type diglist_type::size()</li>
<li>Method void diglist_type::push_back()</li>
<li>Method void diglist_type::pop_back()</li>
<li>Method digit_type diglist_type::back()</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist1</td><td>The digit string of the first number </td></tr>
    <tr><td class="paramname">diglist2</td><td>The digit string of the second number </td></tr>
    <tr><td class="paramname">sign1</td><td>The numeric sign of the first number </td></tr>
    <tr><td class="paramname">sign2</td><td>The numeric sign of the second number </td></tr>
    <tr><td class="paramname">base</td><td>The number base of both numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a37c712840c2d1ab04a8eaddcaca8d487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a37c712840c2d1ab04a8eaddcaca8d487">&sect;&nbsp;</a></span>bitwise_and_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_and_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary AND operation calculated by performing x &amp; y on each digit.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a3fb9d54665f8effdee8f6558c8b9418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a3fb9d54665f8effdee8f6558c8b9418e">&sect;&nbsp;</a></span>bitwise_complement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_complement </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>bitstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Complement function that calculates the binary, or bitwise, complement.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitstring</td><td>The number to modify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a3c42bf237e13b783eb25964ab8864753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a3c42bf237e13b783eb25964ab8864753">&sect;&nbsp;</a></span>bitwise_lshift_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_lshift_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary left shift operation that is equivalent to performing x *= 2 by y times.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_afa2b1c74202f63d6154a720ef55ddf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_afa2b1c74202f63d6154a720ef55ddf87">&sect;&nbsp;</a></span>bitwise_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_operation </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary base relative function that performs one of several bitwise operations (AND, OR, XOR) to two digit strings. The numerical signs are treated separately. Note that this algorithm may be slower since the second integer is copied.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
    <tr><td class="paramname">op</td><td>The bitwise operation to perform per bit 0. COMPLEMENT<ol type="1">
<li>AND</li>
<li>OR</li>
<li>XOR </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_af09cf6405fe577b9fbe5216b9402acfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_af09cf6405fe577b9fbe5216b9402acfd">&sect;&nbsp;</a></span>bitwise_or_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_or_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary OR operation calculated by performing x | y on each digit.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_aeae1f908334d24c17d35ccdcdf85004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aeae1f908334d24c17d35ccdcdf85004e">&sect;&nbsp;</a></span>bitwise_rshift_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_rshift_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary right shift operation that is equivalent to performing x /= 2 by y times.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a47c73aad4c2c9c6af253aa9e6561e2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a47c73aad4c2c9c6af253aa9e6561e2c8">&sect;&nbsp;</a></span>bitwise_xor_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_xor_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary XOR operation calculated by performing x ^ y on each digit.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a556733618d611fdbeb19b1d9d05f72fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a556733618d611fdbeb19b1d9d05f72fe">&sect;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short Precision::Volatile::Int_Operations::compare </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison function that determines which integer is greater than the other.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. It is assumed that this type supports the following:<ul>
<li>Type IntType::diglist_type</li>
<li>Method sign_type IntType::sign()</li>
<li>Method diglist_type IntType::digit_list()</li>
<li>Method size_type DigListType::size()</li>
<li>Method const_iterator diglist_type::crbegin()</li>
<li>Method const_iterator diglist_type::crend()</li>
<li>Method bool <a class="el" href="_precision___shared___helpers_8h.html#ace0ce9e0c82ed3dc0bf03850c520c4a4">IntType::is_negative()</a></li>
<li>Method bool sign_type::value()</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Representation of which number is greater:<ul>
<li>-1 : lhs &lt; rhs (less than)</li>
<li>0 : rhs == lhs (equivalent)</li>
<li>+1 : lhs &gt; rhs (greater than) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="file_a31307128a4a0ef31fd93a303dd8c27ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a31307128a4a0ef31fd93a303dd8c27ca">&sect;&nbsp;</a></span>compare_lists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short Precision::Volatile::Int_Operations::compare_lists </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>More basic function that only compares two digit lists. Because there is no numerical sign information, this is a comparison of the numbers' magnitudes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DigListType</td><td>Type of the STL compliant container holding the digits of a number. It is assumed that this type supports the following:<ul>
<li>Method size_type DigListType::size()</li>
<li>Method const_iterator DigListType::crbegin()</li>
<li>Method const_iterator DigListType::crend()</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist1</td><td>The digit string of the first number </td></tr>
    <tr><td class="paramname">diglist2</td><td>The digit string of the second number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Representation of which number is greater:<ul>
<li>-1 : lhs &lt; rhs (less than)</li>
<li>0 : rhs == lhs (equivalent)</li>
<li>+1 : lhs &gt; rhs (greater than) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="file_a1ee569062ed607d4451f0761ca30396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a1ee569062ed607d4451f0761ca30396d">&sect;&nbsp;</a></span>divide_mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::divide_mod </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>quotient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple divide function taking two digit strings and calculating the quotient and modulus. Algorithm does not need number base information. The division and modulus are defined as follows: Numerator / Denominator = Quotient + Modulus / Denominator This is important because the sign of the modulus will match the sign of the quotient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. In addition to the requirements as detailed by <a class="el" href="_precision___int___operations_8h.html#ad4b05f9d2e26bcd2a8d23991e998444e">multiply()</a>, IntType is assumed to support:<ul>
<li>Method diglist_type IntType::digit_list()</li>
<li>Method IntType IntType::magnitude()</li>
<li>Method void <a class="el" href="_precision___shared___helpers_8h.html#a108ca8db4ef18350f325aa4592990dd2">IntType::make_one()</a></li>
<li>Method void IntType::shift_right(size_type)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
    <tr><td class="paramname">quotient</td><td>Reference to where quotient result is stored </td></tr>
    <tr><td class="paramname">modulus</td><td>Reference to where modulus result is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a68c5754c2c67603014af6e7b2861bce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a68c5754c2c67603014af6e7b2861bce1">&sect;&nbsp;</a></span>exponentiate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::exponentiate </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer exponentiation function that employs the exponentiation by squaring algorithm. This function does not support floating point exponents.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The number to exponentiate </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a198a3d535c575aa4946f460b87ad545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a198a3d535c575aa4946f460b87ad545c">&sect;&nbsp;</a></span>is_neg_one_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType , typename SignType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Precision::Volatile::Int_Operations::is_neg_one_list </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignType &amp;&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to tell if a number is basically -1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DigListType</td><td>Type of the STL compliant container holding the digits of a number. It is assumed that this type supports the following:<ul>
<li>Method size_type DigListType::size()</li>
<li>Method digit_type DigListType::front() </li>
</ul>
</td></tr>
    <tr><td class="paramname">SignType</td><td>Type representing the numerical sign. It is assumed that this type supports:<ul>
<li>bool <a class="el" href="_precision___shared___helpers_8h.html#ace0ce9e0c82ed3dc0bf03850c520c4a4">SignType::is_negative()</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist</td><td>The digit string of the number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the list contains only {1} and the sign is negative. </dd></dl>

</div>
</div>
<a id="file_a833bf7f2e703c3613c56ba0fb3e55a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a833bf7f2e703c3613c56ba0fb3e55a48">&sect;&nbsp;</a></span>is_one_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType , typename SignType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Precision::Volatile::Int_Operations::is_one_list </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignType &amp;&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to tell if a number is basically 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DigListType</td><td>Type of the STL compliant container holding the digits of a number. It is assumed that this type supports the following:<ul>
<li>Method size_type DigListType::size()</li>
<li>Method digit_type DigListType::front() </li>
</ul>
</td></tr>
    <tr><td class="paramname">SignType</td><td>Type representing the numerical sign. It is assumed that this type supports:<ul>
<li>bool SignType::is_positive()</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist</td><td>The digit string of the number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the list contains only {1}. </dd></dl>

</div>
</div>
<a id="file_ac0b1e5560a052947e97648214ec6b99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac0b1e5560a052947e97648214ec6b99a">&sect;&nbsp;</a></span>is_zero_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Precision::Volatile::Int_Operations::is_zero_list </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to tell if a number is basically 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DigListType</td><td>Type of the STL compliant container holding the digits of a number. It is assumed that this type supports the following:<ul>
<li>Method size_type DigListType::size()</li>
<li>Method digit_type DigListType::front()</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist</td><td>The digit string of the number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the list contains only {0}. Note that an empty list or a list with more than one 0's do not count. </dd></dl>

</div>
</div>
<a id="file_a042bf17ea1c0cb1faf74a4d02ad057e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a042bf17ea1c0cb1faf74a4d02ad057e0">&sect;&nbsp;</a></span>logical_and_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_and_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base AND operation calculated by performing x * y on each digit.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a75c37ed972b2c8f5a7b835aa369bc767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a75c37ed972b2c8f5a7b835aa369bc767">&sect;&nbsp;</a></span>logical_complement_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_complement_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Complement function that is relative to the number base of the IntType object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>The integer to find the complement of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a1962d20a311be325ea55f0c3342d412a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a1962d20a311be325ea55f0c3342d412a">&sect;&nbsp;</a></span>logical_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_operation </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>oper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number base relative function that performs one of several logical operations (AND, OR, XOR, COMPL) to two digit strings. The numerical signs are treated separately and go through the respective logical operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
    <tr><td class="paramname">oper</td><td>The operation to perform per digit<ol type="1">
<li>AND</li>
<li>OR</li>
<li>XOR</li>
<li>COMPLEMENT </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a06eda4976a85957d0541a211625929ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a06eda4976a85957d0541a211625929ce">&sect;&nbsp;</a></span>logical_or_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_or_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base OR operation that is equivalent to COMPL( AND( COMPL(x), COMPL(y) ) )</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a8c1686820233a58146b60d3394782353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a8c1686820233a58146b60d3394782353">&sect;&nbsp;</a></span>logical_xor_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_xor_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base XOR operation calculated by performing x + y on each digit.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ac07007c8ef804c0ceb152357bdc24c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac07007c8ef804c0ceb152357bdc24c0c">&sect;&nbsp;</a></span>logical_xor_rev_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_xor_rev_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>xor_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A specical logical base reverse XOR operation that can take the result of a logical XOR operation and recalculate one of the original keys. This is akin to the special case: binary XOR, where applying XOR again returns the original key.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xor_res</td><td>The first integer which was the result of a previous xor operation </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ad4b05f9d2e26bcd2a8d23991e998444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ad4b05f9d2e26bcd2a8d23991e998444e">&sect;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::multiply </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple multiply function taking two digit strings and calculating the product. Algorithm does not need number base information.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. In addition to the requirements as detailed by <a class="el" href="_precision___int___operations_8h.html#a96134d0ff039e6a1cf7d596db9bc17a2">add()</a> and <a class="el" href="_precision___int___operations_8h.html#ac6c0804a153fd09bede916d85dde6236">multiply_diglist()</a>, IntType is assumed to support:<ul>
<li>Type IntType::size_type</li>
<li>Method bool <a class="el" href="_precision___shared___helpers_8h.html#ade132cdfd51bb038d8b3f885b7482476">IntType::is_zero()</a></li>
<li>Method bool <a class="el" href="_precision___shared___helpers_8h.html#af98063dd6c3b5a6457698a33f24a90f0">IntType::is_one()</a></li>
<li>Method bool <a class="el" href="_precision___shared___helpers_8h.html#a3e0dff28e3f40142f9f685589ec554d5">IntType::is_neg_one()</a></li>
<li>Method void <a class="el" href="_precision___shared___helpers_8h.html#ad3c98a309788b71dfcf713203cac47f4">IntType::negate()</a></li>
<li>Method void <a class="el" href="_precision___shared___helpers_8h.html#aeb5d533c78128637e2a0ef4c180b2f69">IntType::make_zero()</a></li>
<li>Method void IntType::sign(sign_type)</li>
<li>Method void IntType::shift_left(size_type)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ac6c0804a153fd09bede916d85dde6236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac6c0804a153fd09bede916d85dde6236">&sect;&nbsp;</a></span>multiply_diglist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::multiply_diglist </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>fac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper multiply function that acts as an accumulation function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>Number type from which type and base information is extracted. IntType is is assumed to support the following:<ul>
<li>Type IntType::digit_type</li>
<li>Type IntType::catalyst_type</li>
<li>Method digit_type IntType::base()</li>
<li>Method size_type IntType::count_digits()</li>
<li>Method digit_type&amp; IntType::digit(size_type)</li>
<li>Method void IntType::append(digit_type)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The integer to multiply </td></tr>
    <tr><td class="paramname">fac</td><td>The single digit multiplication factor that belongs in the range [0, base-1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
