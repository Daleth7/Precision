<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Precision: Precision/General_Base/Impl/Precision_Int_Operations.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Precision
   &#160;<span id="projectnumber">6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cda8f6e95b399098ad72a7ded9dd64b1.html">Precision</a></li><li class="navelem"><a class="el" href="dir_11d2f114510e12b732e8cd61583b4fd7.html">General_Base</a></li><li class="navelem"><a class="el" href="dir_956aa70110c06265813f068c073f195e.html">Impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Precision_Int_Operations.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &quot;Precision_Int_Operations.inl&quot;</code><br />
</div>
<p><a href="_precision___int___operations_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aad88376a38a12f29e89477a79f31c363"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aad88376a38a12f29e89477a79f31c363"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#aad88376a38a12f29e89477a79f31c363">Precision::Volatile::Int_Operations::add</a> (typename IntType::diglist_type &amp;diglist1, typename IntType::diglist_type diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, typename IntType::digit_type base)</td></tr>
<tr class="separator:aad88376a38a12f29e89477a79f31c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ad4b05f9d2e26bcd2a8d23991e998444e">Precision::Volatile::Int_Operations::multiply</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:ad4b05f9d2e26bcd2a8d23991e998444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740c2b58eb77817f7f2f946c81ad8ad4"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a740c2b58eb77817f7f2f946c81ad8ad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a740c2b58eb77817f7f2f946c81ad8ad4">Precision::Volatile::Int_Operations::divide_mod</a> (const IntType &amp;lhs, const IntType &amp;rhs, IntType *div_req, IntType *mod_req)</td></tr>
<tr class="separator:a740c2b58eb77817f7f2f946c81ad8ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87da65ac732dcae51e631de9edf3fd4"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ad87da65ac732dcae51e631de9edf3fd4"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ad87da65ac732dcae51e631de9edf3fd4">Precision::Volatile::Int_Operations::bitwise_complement</a> (const IntType &amp;bitstring)</td></tr>
<tr class="separator:ad87da65ac732dcae51e631de9edf3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505c93f73925424dbdc809ad786be895"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a505c93f73925424dbdc809ad786be895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a505c93f73925424dbdc809ad786be895">Precision::Volatile::Int_Operations::bitwise_operation</a> (IntType &amp;lhs, IntType rhs, std::function&lt; bool(bool, bool)&gt; &amp;&amp;oper)</td></tr>
<tr class="separator:a505c93f73925424dbdc809ad786be895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a37c712840c2d1ab04a8eaddcaca8d487">Precision::Volatile::Int_Operations::bitwise_and_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a37c712840c2d1ab04a8eaddcaca8d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09cf6405fe577b9fbe5216b9402acfd"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:af09cf6405fe577b9fbe5216b9402acfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#af09cf6405fe577b9fbe5216b9402acfd">Precision::Volatile::Int_Operations::bitwise_or_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:af09cf6405fe577b9fbe5216b9402acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a47c73aad4c2c9c6af253aa9e6561e2c8">Precision::Volatile::Int_Operations::bitwise_xor_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a47c73aad4c2c9c6af253aa9e6561e2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c42bf237e13b783eb25964ab8864753"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a3c42bf237e13b783eb25964ab8864753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a3c42bf237e13b783eb25964ab8864753">Precision::Volatile::Int_Operations::bitwise_lshift_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a3c42bf237e13b783eb25964ab8864753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae1f908334d24c17d35ccdcdf85004e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aeae1f908334d24c17d35ccdcdf85004e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#aeae1f908334d24c17d35ccdcdf85004e">Precision::Volatile::Int_Operations::bitwise_rshift_eq</a> (IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:aeae1f908334d24c17d35ccdcdf85004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cedf60482ffd9480778ae76874a5910"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a9cedf60482ffd9480778ae76874a5910"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a9cedf60482ffd9480778ae76874a5910">Precision::Volatile::Int_Operations::logical_operation</a> (typename IntType::diglist_type &amp;diglist1, typename IntType::diglist_type diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, unsigned short oper, typename IntType::digit_type base)</td></tr>
<tr class="separator:a9cedf60482ffd9480778ae76874a5910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2884ca9a64093584d5fc2ea390fc877"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ae2884ca9a64093584d5fc2ea390fc877"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ae2884ca9a64093584d5fc2ea390fc877">Precision::Volatile::Int_Operations::logical_and</a> (typename IntType::diglist_type &amp;diglist1, typename IntType::diglist_type diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, typename IntType::digit_type base)</td></tr>
<tr class="separator:ae2884ca9a64093584d5fc2ea390fc877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0912057a8eacacc159c55fb914e177d"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ac0912057a8eacacc159c55fb914e177d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ac0912057a8eacacc159c55fb914e177d">Precision::Volatile::Int_Operations::logical_or</a> (typename IntType::diglist_type &amp;diglist1, typename IntType::diglist_type diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, typename IntType::digit_type base)</td></tr>
<tr class="separator:ac0912057a8eacacc159c55fb914e177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50008d122401db9c2f9d1e0a2cb50561"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a50008d122401db9c2f9d1e0a2cb50561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a50008d122401db9c2f9d1e0a2cb50561">Precision::Volatile::Int_Operations::logical_xor</a> (typename IntType::diglist_type &amp;diglist1, typename IntType::diglist_type diglist2, typename IntType::sign_type &amp;sign1, typename IntType::sign_type sign2, typename IntType::digit_type base)</td></tr>
<tr class="separator:a50008d122401db9c2f9d1e0a2cb50561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb7383260b15d695948687a6c8d7bc"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aebcb7383260b15d695948687a6c8d7bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#aebcb7383260b15d695948687a6c8d7bc">Precision::Volatile::Int_Operations::logical_complement</a> (typename IntType::diglist_type &amp;diglist, typename IntType::sign_type &amp;int_sign, typename IntType::digit_type base)</td></tr>
<tr class="separator:aebcb7383260b15d695948687a6c8d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556733618d611fdbeb19b1d9d05f72fe"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a556733618d611fdbeb19b1d9d05f72fe"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a556733618d611fdbeb19b1d9d05f72fe">Precision::Volatile::Int_Operations::compare</a> (const IntType &amp;lhs, const IntType &amp;rhs)</td></tr>
<tr class="separator:a556733618d611fdbeb19b1d9d05f72fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memTemplParams" colspan="2">template&lt;typename DigListType &gt; </td></tr>
<tr class="memitem:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#a31307128a4a0ef31fd93a303dd8c27ca">Precision::Volatile::Int_Operations::compare_lists</a> (const DigListType &amp;diglist1, const DigListType &amp;diglist2)</td></tr>
<tr class="separator:a31307128a4a0ef31fd93a303dd8c27ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b1e5560a052947e97648214ec6b99a"><td class="memTemplParams" colspan="2">template&lt;typename DigListType &gt; </td></tr>
<tr class="memitem:ac0b1e5560a052947e97648214ec6b99a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_precision___int___operations_8h.html#ac0b1e5560a052947e97648214ec6b99a">Precision::Volatile::Int_Operations::is_zero_list</a> (const DigListType &amp;diglist)</td></tr>
<tr class="separator:ac0b1e5560a052947e97648214ec6b99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file centralizes the base algorithms all the number types use. By doing this, the library can be extended more easily. An example of this is the difference between Dynamic and Static number types. Despite sharing the same algorithms, their behaviour for compile-time and run-time is different enough that they cannot share the same inheritance tree or utilize composition. The algorithms are placed under the Volatile namespace since they require the number base to be passed as a parameter to correctly run the algorithm. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="file_aad88376a38a12f29e89477a79f31c363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aad88376a38a12f29e89477a79f31c363">&sect;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::add </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::diglist_type&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple add function taking two digit strings and calculating the sum. Note that the operation may be slow since the second digit string is copied. [TODO: Optimize algorithm to not make copies] [TODO: Optimize algorithm to avoid iterating when borrowing] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist1</td><td>The digit string of the first number </td></tr>
    <tr><td class="paramname">diglist2</td><td>The digit string of the second number </td></tr>
    <tr><td class="paramname">sign1</td><td>The numeric sign of the first number </td></tr>
    <tr><td class="paramname">sign2</td><td>The numeric sign of the second number </td></tr>
    <tr><td class="paramname">base</td><td>The number base of both numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a37c712840c2d1ab04a8eaddcaca8d487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a37c712840c2d1ab04a8eaddcaca8d487">&sect;&nbsp;</a></span>bitwise_and_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_and_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary AND operation calculated by performing x &amp; y on each digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ad87da65ac732dcae51e631de9edf3fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ad87da65ac732dcae51e631de9edf3fd4">&sect;&nbsp;</a></span>bitwise_complement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType Precision::Volatile::Int_Operations::bitwise_complement </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>bitstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Complement function that calculates the binary, or bitwise, complement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitstring</td><td>The original number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a3c42bf237e13b783eb25964ab8864753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a3c42bf237e13b783eb25964ab8864753">&sect;&nbsp;</a></span>bitwise_lshift_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_lshift_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary left shift operation that is equivalent to performing x *= 2 by y times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a505c93f73925424dbdc809ad786be895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a505c93f73925424dbdc809ad786be895">&sect;&nbsp;</a></span>bitwise_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_operation </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(bool, bool)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>oper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary base relative function that performs one of several bitwise operations (AND, OR, XOR) to two digit strings. The numerical signs are treated separately. Note that this algorithm may be slower since the second integer is copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
    <tr><td class="paramname">oper</td><td>A callback function that performs the bitwise operation on each digit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_af09cf6405fe577b9fbe5216b9402acfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_af09cf6405fe577b9fbe5216b9402acfd">&sect;&nbsp;</a></span>bitwise_or_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_or_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary OR operation calculated by performing x | y on each digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_aeae1f908334d24c17d35ccdcdf85004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aeae1f908334d24c17d35ccdcdf85004e">&sect;&nbsp;</a></span>bitwise_rshift_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_rshift_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary right shift operation that is equivalent to performing x /= 2 by y times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a47c73aad4c2c9c6af253aa9e6561e2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a47c73aad4c2c9c6af253aa9e6561e2c8">&sect;&nbsp;</a></span>bitwise_xor_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::bitwise_xor_eq </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary XOR operation calculated by performing x ^ y on each digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a556733618d611fdbeb19b1d9d05f72fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a556733618d611fdbeb19b1d9d05f72fe">&sect;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short Precision::Volatile::Int_Operations::compare </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison function that determines which integer is greater than the other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Representation of which number is greater:<ul>
<li>-1 : lhs &lt; rhs (less than)</li>
<li>0 : rhs == lhs (equivalent)</li>
<li>+1 : lhs &gt; rhs (greater than) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="file_a31307128a4a0ef31fd93a303dd8c27ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a31307128a4a0ef31fd93a303dd8c27ca">&sect;&nbsp;</a></span>compare_lists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short Precision::Volatile::Int_Operations::compare_lists </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>More basic function that only compares two digit lists. Because there is no numerical sign information, this is a comparison of the numbers' magnitudes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist1</td><td>The digit string of the first number </td></tr>
    <tr><td class="paramname">diglist2</td><td>The digit string of the second number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a740c2b58eb77817f7f2f946c81ad8ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a740c2b58eb77817f7f2f946c81ad8ad4">&sect;&nbsp;</a></span>divide_mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::divide_mod </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType *&#160;</td>
          <td class="paramname"><em>div_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType *&#160;</td>
          <td class="paramname"><em>mod_req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple divide function taking two digit strings and calculating the quotient and modulus. Algorithm does not need number base information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
    <tr><td class="paramname">div_req</td><td>Pointer to where quotient result is stored </td></tr>
    <tr><td class="paramname">mod_req</td><td>Pointer to where modulus result is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ac0b1e5560a052947e97648214ec6b99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac0b1e5560a052947e97648214ec6b99a">&sect;&nbsp;</a></span>is_zero_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DigListType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Precision::Volatile::Int_Operations::is_zero_list </td>
          <td>(</td>
          <td class="paramtype">const DigListType &amp;&#160;</td>
          <td class="paramname"><em>diglist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to tell if a number is basically 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist</td><td>The digit string of the number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the list contains only {0}. Note that an empty list or a list with more than one 0's do not count. </dd></dl>

</div>
</div>
<a id="file_ae2884ca9a64093584d5fc2ea390fc877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ae2884ca9a64093584d5fc2ea390fc877">&sect;&nbsp;</a></span>logical_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_and </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::diglist_type&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base AND operation calculated by performing x * y on each digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_aebcb7383260b15d695948687a6c8d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aebcb7383260b15d695948687a6c8d7bc">&sect;&nbsp;</a></span>logical_complement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_complement </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>int_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Complement function that is relative to the number base of the IntType object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist</td><td>The digit string of the integer </td></tr>
    <tr><td class="paramname">int_sign</td><td>The numerical sign of the integer </td></tr>
    <tr><td class="paramname">base</td><td>The number base of the integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a9cedf60482ffd9480778ae76874a5910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a9cedf60482ffd9480778ae76874a5910">&sect;&nbsp;</a></span>logical_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_operation </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::diglist_type&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number base relative function that performs one of several logical operations (AND, OR, XOR, COMPL) to two digit strings. The numerical signs are treated separately and go through the respective bitwise operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diglist1</td><td>The digit string of the first number </td></tr>
    <tr><td class="paramname">diglist2</td><td>The digit string of the second number </td></tr>
    <tr><td class="paramname">sign1</td><td>The numeric sign of the first number </td></tr>
    <tr><td class="paramname">sign2</td><td>The numeric sign of the second number </td></tr>
    <tr><td class="paramname">oper</td><td>Determines which operation to perform<ol type="1">
<li>AND</li>
<li>OR</li>
<li>XOR</li>
<li>COMPLEMENT </li>
</ol>
</td></tr>
    <tr><td class="paramname">base</td><td>The number base of both numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ac0912057a8eacacc159c55fb914e177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac0912057a8eacacc159c55fb914e177d">&sect;&nbsp;</a></span>logical_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_or </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::diglist_type&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base OR operation that is equivalent to COMPL( AND( COMPL(x), COMPL(y) ) ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_a50008d122401db9c2f9d1e0a2cb50561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a50008d122401db9c2f9d1e0a2cb50561">&sect;&nbsp;</a></span>logical_xor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::logical_xor </td>
          <td>(</td>
          <td class="paramtype">typename IntType::diglist_type &amp;&#160;</td>
          <td class="paramname"><em>diglist1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::diglist_type&#160;</td>
          <td class="paramname"><em>diglist2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type &amp;&#160;</td>
          <td class="paramname"><em>sign1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::sign_type&#160;</td>
          <td class="paramname"><em>sign2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntType::digit_type&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical base XOR operation calculated by performing x + y on each digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="file_ad4b05f9d2e26bcd2a8d23991e998444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ad4b05f9d2e26bcd2a8d23991e998444e">&sect;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Precision::Volatile::Int_Operations::multiply </td>
          <td>(</td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple multiply function taking two digit strings and calculating the product. Algorithm does not need number base information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first integer </td></tr>
    <tr><td class="paramname">rhs</td><td>The second integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
